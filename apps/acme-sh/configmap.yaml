apiVersion: v1
kind: ConfigMap
metadata:
  name: acme-sh-scripts
  namespace: homelab
data:
  entrypoint.sh: |
    #!/bin/sh
    set -eu

    : "${LE_CONFIG_HOME:=/acme.sh}"
    : "${ACME_DOMAIN:=wst.sh}"
    : "${ACME_SERVER:=letsencrypt}"
    : "${ACME_SECRET_NAME:=wst-sh-wildcard-tls}"
    : "${ACME_TARGET_NAMESPACES:=auth,homelab,observability,databases,beszel-hub}"
    : "${ACME_EXPORT_DIR:=/export}"
    : "${ACME_EXPORT_ENABLED:=true}"

    if [ -z "${ACME_EMAIL:-}" ]; then
      echo "ACME_EMAIL is required" >&2
      exit 1
    fi
    if [ -z "${CF_Token:-}" ] || [ -z "${CF_Zone_ID:-}" ]; then
      echo "CF_Token and CF_Zone_ID are required for dns_cf" >&2
      exit 1
    fi

    apk add --no-cache kubectl >/dev/null

    if [ ! -f "${LE_CONFIG_HOME}/${ACME_DOMAIN}/${ACME_DOMAIN}.cer" ]; then
      acme.sh --register-account -m "${ACME_EMAIL}" --server "${ACME_SERVER}" --home "${LE_CONFIG_HOME}"
      acme.sh --issue --dns dns_cf -d "${ACME_DOMAIN}" -d "*.${ACME_DOMAIN}" --server "${ACME_SERVER}" --home "${LE_CONFIG_HOME}"
    fi

    cert_dir="${LE_CONFIG_HOME}/certs"
    mkdir -p "${cert_dir}"

    ecc_flag=""
    if [ -d "${LE_CONFIG_HOME}/${ACME_DOMAIN}_ecc" ]; then
      ecc_flag="--ecc"
    fi

    acme.sh --install-cert -d "${ACME_DOMAIN}" ${ecc_flag} \
      --key-file "${LE_CONFIG_HOME}/certs/tls.key" \
      --fullchain-file "${LE_CONFIG_HOME}/certs/tls.crt" \
      --reloadcmd "/scripts/deploy.sh" \
      --home "${LE_CONFIG_HOME}"

    /scripts/deploy.sh

    exec /entry.sh daemon

  deploy.sh: |
    #!/bin/sh
    set -eu

    : "${LE_CONFIG_HOME:=/acme.sh}"
    : "${ACME_DOMAIN:=wst.sh}"
    : "${ACME_SECRET_NAME:=wst-sh-wildcard-tls}"
    : "${ACME_TARGET_NAMESPACES:=auth,homelab,observability,databases,beszel-hub}"
    : "${ACME_EXPORT_DIR:=/export}"
    : "${ACME_EXPORT_ENABLED:=true}"

    cert_dir="${LE_CONFIG_HOME}/certs"
    tls_crt="${cert_dir}/tls.crt"
    tls_key="${cert_dir}/tls.key"

    if [ ! -f "${tls_crt}" ] || [ ! -f "${tls_key}" ]; then
      echo "Missing certificate files in ${cert_dir}" >&2
      exit 1
    fi

    for ns in $(echo "${ACME_TARGET_NAMESPACES}" | tr ',' ' '); do
      if ! kubectl get namespace "${ns}" >/dev/null 2>&1; then
        echo "Skipping missing namespace: ${ns}" >&2
        continue
      fi
      kubectl -n "${ns}" create secret tls "${ACME_SECRET_NAME}" \
        --cert="${tls_crt}" \
        --key="${tls_key}" \
        --dry-run=client -o yaml | kubectl apply -f -
    done

    if [ "${ACME_EXPORT_ENABLED}" = "true" ]; then
      if [ ! -d "${ACME_EXPORT_DIR}" ]; then
        echo "Export directory not found: ${ACME_EXPORT_DIR}" >&2
        exit 1
      fi
      export_path="${ACME_EXPORT_DIR%/}/${ACME_DOMAIN}"
      mkdir -p "${export_path}"

      cp -f "${tls_key}" "${export_path}/privkey.pem"
      if ! chmod 600 "${export_path}/privkey.pem"; then
        echo "Warning: could not chmod privkey.pem" >&2
      fi
      cp -f "${tls_crt}" "${export_path}/fullchain.pem"
      if ! chmod 644 "${export_path}/fullchain.pem"; then
        echo "Warning: could not chmod fullchain.pem" >&2
      fi

      cp -f "${tls_crt}" "${export_path}/tls.crt"
      if ! chmod 644 "${export_path}/tls.crt"; then
        echo "Warning: could not chmod tls.crt" >&2
      fi
      cp -f "${tls_key}" "${export_path}/tls.key"
      if ! chmod 600 "${export_path}/tls.key"; then
        echo "Warning: could not chmod tls.key" >&2
      fi

      date -u +"%Y-%m-%dT%H:%M:%SZ" > "${export_path}/last_synced.txt"
    fi
